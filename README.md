# Лабораторные работы ОАИП
### ![](https://i.ibb.co/6WJd2wN/extrasign.png) **Данный код не является образцовым. Прикрепляю ссылку на [анализатор кода.](https://sonarcloud.io/project/overview?id=krilop_labs)**
**Если вы хотите связаться с автором, ссылки в профиле вам в этом помогут.**
## Содержание
### Первый семестр: 
1. **[Лабораторная 1](#лабораторная-1)**
2. **[Лабораторная 2](#лабораторная-2)**
3. **[Лабораторная 3](#лабораторная-3)**
4. **[Лабораторная 4](#лабораторная-4)**
6. **[Лабораторная 5](#лабораторная-5)**
6. **[Лабораторная 6](#лабораторная-6)**
7. **[Лабораторная 7](#лабораторная-7)**
8. **[Лабораторная 8](#лабораторная-8)**
### Второй семестр:
1. **[Лабораторная 9](#лабораторная-9)**
2. **[Лабораторная 10](#лабораторная-10)**
3. **[Лабораторная 11](#лабораторная-11)**
4. **[Лабораторная 12](#лабораторная-12)**
5. **[Лабораторная 13](#лабораторная-13)**

## Лабораторная 1

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab1/task1/main.c)**. Вввести длины ребер куба. Найти объем куба и площадь его боковой поверхности. Результат вывести с точностью до трех знаков после запятой.\
**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab1/task2/main.c)**. Определить, имеется ли среди целых чисел a, b и c хотя бы одно чётное.\
**[Задача 3](https://github.com/krilop/labs/tree/master/term1/lab1/task3/main.c)**. Составьте алгоритм решения неравенства ax2+bx+c<0.\
**[Задача 4](https://github.com/krilop/labs/tree/master/term1/lab1/task4/main.c)**. Для натурального числа К напечатать фразу "мы нашли К грибов в лесу", согласовав окончание слова "гриб" с числом К.\
**[Вернуться к содержанию.](#Содержание)**
## Лабораторная 2

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab2/task1/main.c)**. Дано натуральное число n. Выяснить, можно ли представить n! в виде произведения трёх последовательных целых чисел.\
**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab2/task2/main.c)**. Дана последовательность, каждый член которой равен его порядковому номеру в последовательности, возведенному в куб. Номера её первого и последнего членов - 1 и n соответственно.  Найдите сумму S и произведение P тех её членов, номера  которых являются:
а) нечетными
б) четными\
**[Задача 3](https://github.com/krilop/labs/tree/master/term1/lab2/task3/main.c)**. Дано число Х в градусах. Найти значение sinX используя разложение в ряд Тейлора.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 3

#### Доп. условия:

* Во всех заданиях использовать статические массивы.
Сначала выделить место на 100 элементов, а потом использовать столько, сколько скажет пользователь.
* Предусмотреть ввод с клавиатуры и инициализацию массива случайными значениями (по желанию пользователя).
* При вводе чисел обязательно выводить приглашающие строки, а также выполнять проверку на корректность ввода;
* избегать названий переменных, не отражающих своей сути, например, а, nn, s и т.п. Исключение - счетные переменные в циклах i. 
* Для индексации лучше использовать col (столбец) и row (строка).

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab3/task1/main.c)**. В одномерном массиве, состоящем из n вещественных элементов, вычислить:
- количество элементов массива, равных 0;
- сумму элементов массива, расположенных после минимального элемента.

**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab3/task2/main.c)**. В массиве из n элементов циклически сдвинуть все четные элементы на k влево. Нечетные оставить на своих местах.\
**[Задача 3](https://github.com/krilop/labs/tree/master/term1/lab3/task3/main.c)**. Для арифметических операций с большими числами, которые не могут быть представлены в памяти компьютера, используется следующий прием. Каждая цифра таких чисел записывается в отдельный элемент массива, и необходимые операции проводятся с элементами массива цифр. Составить программу, выполняющую сложение 30-значных чисел.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 4

#### Доп. условия:

* Во всех заданиях использовать статические массивы.
  Сначала выделить место на 100х100 элементов, а потом использовать столько, сколько скажет пользователь.
* Предусмотреть ввод с клавиатуры и инициализацию массива случайными значениями (по желанию пользователя).
* При вводе чисел обязательно выводить приглашающие строки, а также выполнять проверку на корректность ввода;
* избегать названий переменных, не отражающих своей сути, например, а, nn, s и т.п. Исключение - счетные переменные в циклах i.
* Для индексации лучше использовать col (столбец) и row (строка).

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab4/task1/main.c)**. Дана целочисленная квадратная матрица. Определить: 
* Сумму элементов в тех столбцах, которые не содержат отрицательных элементов;
* Минимум среди сумм модулей элементов диагоналей, параллельных побочной диагонали матрицы.

**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab4/task2/main.c)**. Найти в матрице первый столбец, все элементы которого равны нулю. Знаки элементов строки с таким же номером изменить на противоположные.\
**[Задача 3](https://github.com/krilop/labs/tree/master/term1/lab4/task3/main.c)**. В квадратной матрице размером NxN найти минмальный четный элемент в 3-ой области(см. рис. 1)\
![](https://i.ibb.co/nsLyw5b/image.png)\
 **Рисунок 1.**\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 5
#### Доп. условия:
* В случае невозможности выполнения операции, неверных аргументов, не нахождения элементов - выводить соответствующие сообщения на экран. 
* Ни одна функция не должна превышать размера в 40-50 строк. Исключение может составить только функция main при условии аккуратной организации и хорошей читаемости. 
* Функции для работы с массивом не должны ничего выводить на экран. Исключение - функция для просмотра массива. Поэтому любые сообщения должны выводиться на экран в функциях более высокого уровня, которые отвечают за интерфейс пользователя (например, функция main). 
* Функции для работы с массивом/матрицей должны быть вынесены в отдельные файлы исходного кода arrays.h и arrays.c. В файле с main библиотека включается с помощью директивы #include ""
* Во всех заданиях использовать динамическое выделение памяти. Желательно делать все функции типа void.

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab5/task1/main.c)**. Заполнить массив случайными числами. Удалить из массива все элементы с чётным значением.\
**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab5/task2/main.c)**. В двумерном массиве натуральных чисел (количество чисел в строке может быть различным, последнее число - 0) удалить строку с минимальной суммой элементов (порядок остальных строк не менять).\
**[Задача 3](https://github.com/krilop/labs/tree/master/term1/lab5/task3/main.c)**. Дан двумерный массив ненулевых целых чисел. Определить максимально длинную последовательность положительных чисел. Массив просматривается построчно сверху вниз, а в каждой строке - слева направо. Сохранение знака при переходе на новую строку также учитывать.\
**[Вернуться к содержанию.](#Содержание)**
## Лабораторная 6
#### Доп. условия:
* Все сортировки оформлять через функции.
* Во второй задаче использовать дополнительные массивы запрещено.
* Если не указан конкретный тип сортировки, он остается на выбор программиста.
* Во всех заданиях использовать динамическое выделение памяти.
* Желательно делать все функции типа void.
* Для 1-й задачи необходимо замерить время выполнения сортировки в секундах и/или миллисекундах (проверять будем на больших размерах массива – 1000, 10000).
* Провести сравнение времени сортировки с другим способом на ваш выбор, например, пузырьком.
* Рассмотреть “худший” случай (массив отсортирован в обратном порядке).

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab6/task1/main.c)**. В одномерном массиве выполнить сортировку элементов расположенных после первого положительного. Методом Шелла.\
**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab6/task2/main.c)**. В матрице размером NxM выполнить сортировку строк по возрастанию произведения отрицательных элементов методом слияния.(Работает, но ожидается обновление)\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 7
#### Доп. условия:
* Во всех заданиях использовать динамическое выделение памяти.
* Во всех задачах разрабатывать свои функции для работы со строками.(string.h запрещена) 
* Желательно использовать указатели на функции для каждого задания.
* Необходимо создать Меню для выбора пользователем задачи 1 или 2, обращение к которым реализовать через указатель на функцию.

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab7/functions.c)**. Дана строка. Найти сумму чисел в строке.\
**[Задача 2](https://github.com/krilop/labs/tree/master/term1/lab7/functions.c)**. Даны строки S, S0 и числа k, m. Вставить c k-ой позиции строки S первые k символов из строки S0\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 8
#### Доп. условия:
* Во всех заданиях использовать динамическое выделение памяти.
* Во всех задачах разрабатывать свои функции для работы со строками.(string.h запрещена)
* Желательно использовать указатели на функции для каждого задания.
* Организовать ввод массива строк через аргументы командной строки (int main(int argc, char **argv){…}). После этого скопировать строки из командной строки в динамический массив и отсортировать его заданным методом.

**[Задача 1](https://github.com/krilop/labs/tree/master/term1/lab8/main.c)**. Отсортировать методом слияния массив строк по убыванию длины строки.(Работает, но ожидается обновление)\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 9

* Реализовать функцию для создания массива структур.
* Реализовать функцию для вывода массива структур на экран.
* Реализовать функцию для инициализации экземпляра структуры.
* Реализовать функции сортировки массива по каждому полю структуры. (Например, можно отсортировать студентов сначала по дате рождения, затем передумать и отсортировать по среднему баллу).
* Реализовать меню, для проверки функционала.
* Функции не должны привязываться к конкретному массиву: таковой должен передаваться в качестве аргумента.
* В качестве типа одного из полей структуры использовать enum (например, для цвета).
* Реализовать функцию для удаления структуры из массива.
* Реализовать сортировку по двум полям одновременно. (Например, отсортировать автомобили по цвету, так чтобы все автомобили одного цвета шли в порядке года выпуска). **[Был реализован компаратор.](https://github.com/krilop/labs/tree/master/term2/lab1/sorts.c)**

**[Исходный код](https://github.com/krilop/labs/tree/master/term2/lab1/main.c)**. Распарсить html-файл любого списка или каталога.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 10

Написать программу сжатия текстового файла по алгоритму:

* Подсчет частоты встречи каждого слова в файле.
* Поиск самого популярного среди длинных слов (А).
* Поиск самого непопулярного среди коротких слов (В).
* Замена всех слов А и В друг на друга.
* Повтор пунктов 2-4 до тех пор, пока это имеет смысл.

**[Исходный код](https://github.com/krilop/labs/tree/master/term2/lab2/main.c)**.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 11

Написать программу обработки для bmp-изображений с сохранением результата в отдельный bmp файл.

* Варианты обработки – перевод изображения в негатив, перевод изображения в черно-белые цвета.
* Название файла для обработки должно вводиться пользователем.
* Если файл не подходит для программы, программа должна сообщить об ошибке и корректно завершиться.
* Достаточно обрабатывать только структуры типа BITMAPINFOHEADER, только 24-bit изображения.
* Не использовать WINAPI, структуры описывать самостоятельно.
* Работу с пикселями реализовать через структуры.
* Реализовать медианную фильтрацию.
* Реализовать гамма-коррекцию.
* Параметры преобразований изображений задаются в клавиатуры.

**[Исходный код](https://github.com/krilop/labs/tree/master/term2/lab3/main.c)**.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 12

Алгоритм:
1) Пользователь загадывает объект.
2) Программа задает вопросы, на которые пользователь отвечает да/нет.
3) Каждый ответ приводит к очередному вопросу из дерева. Так до тех пор, пока не будет достигнут конец (лист) с ответом.
4) Если ответ неверный, программа должна предложить ввести данные о загаданном объекте (отличительный вопрос) и запомнить новый объект.

Доп. условия:
* Описать отдельное API (библиотечку) для работы с двоичным деревом.
* Размер дерева не должен ограничиваться хардкодом (дефайнами, константами, максимальным размером, введенным с клавиатуры и т.п.), то есть дерево должно иметь возможность расти безгранично.
* Реализовать функцию сохранения / загрузки базы данных об объектах (сохранение дерева в файл). Чтобы не вносить базу каждый раз заново.
* Допилить какую-нибудь интересную фичу на свой вкус. **Было выбрано реализовать АВЛ-дерево**


**[Исходный код](https://github.com/krilop/labs/tree/master/term2/lab4/main.c)**. Написать программу-аналог Акинатора.\
**[Вернуться к содержанию.](#Содержание)**

## Лабораторная 13

Программа должна выполнять поиск IP адреса по доменному имени в файле, содержащем DNS таблицу. Поиск необходимо реализовать через кэш с алгоритмом LRU.

1) 	Пользователь задает доменное имя.
2) 	Программа проверяет наличие данных в кэше:
      если HIT (присутствует в кэше) – возвращает IP адрес пользователю.
      если MISS (отсутствует в кэше) – программа производит поиск по файлу, помещает запись в кэш и возвращает IP адрес.


Кэш должен содержать значения <key, value>, где k – это доменное имя, а v – IP адрес. Данные в кэш помещаются по алгоритму LRU.

Примерная структурная схема кэша:\
![](https://i.ibb.co/QC9jHPr/Image.png)\
DNS-файл содержит данные вида:\
lms.bsuir.by            IN      A            192.168.251.23      (тип 1)\
lms2.bsuir.by      IN      CNAME      lms.bsuir.by            (тип 2)

Доп. условия:
* Реализовать алгоритм хеширования.
* Реализовать кэш (размер кэша ограничен программой!!!) с алгоритмом LRU. 
* Реализовать поиск для записей типа 1. 
* Подготовить файл для тестирования программы. 
* Реализовать поиск для записей типа 2. 
* Добавить возможность добавления записей в файл (валидации на ввод IP и дублирование записей!!!).
* Реализовать поиск всех доменных имен для IP адреса.

**[Исходный код](https://github.com/krilop/labs/tree/master/term2/lab5/main.c)**. Написать программу поиска с кэшем.\
**[Вернуться к содержанию.](#Содержание)**

